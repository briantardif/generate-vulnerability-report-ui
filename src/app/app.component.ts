import {Component, ViewChild} from '@angular/core';
import {RouterOutlet} from '@angular/router';
import {JsonEditorComponent, JsonEditorOptions, NgJsonEditorModule} from 'ang-jsoneditor';
import {Vulnerability, VulnerabilityReport} from './app.models';
import * as XLSX from 'xlsx';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterOutlet, NgJsonEditorModule],
  templateUrl: './app.component.html',
  styleUrl: './app.component.css'
})
export class AppComponent {
  options: JsonEditorOptions = new JsonEditorOptions();
  @ViewChild('jsonEditor') jsonEditor!: JsonEditorComponent;
  vulnerabilities: Vulnerability[] = [];
  vulnerabilityReport: VulnerabilityReport | undefined = undefined;

  constructor() {
    this.options = new JsonEditorOptions();
    this.options.mode = 'view';
    this.options.name = 'Current Vulnerabilities';
  }

  onFileChange(ev: any) {
    let workBook: any = null;
    let jsonData: any = null;
    const reader = new FileReader();
    const file = ev.target.files[0];
    reader.onload = (event) => {
      const data = reader.result;
      workBook = XLSX.read(data, {type: 'binary'});
      jsonData = workBook.SheetNames.reduce((initial: any, name: any) => {
        const sheet = workBook.Sheets[name];
        initial[name] = XLSX.utils.sheet_to_json(sheet);
        return initial;
      }, {});

      jsonData.Sheet1.forEach((cve: any) => {
        this.vulnerabilities.push({
          CVES: JSON.parse(cve.CVES),
          CVSS3SCORE: cve.CVSS3SCORE,
          FINDINGID: cve.FINDINGID,
          IMAGEDIGEST: cve.IMAGEDIGEST,
          PACKAGES: JSON.parse(cve.PACKAGES),
          REGISTRYRESOURCEID: cve.REGISTRYRESOURCEID,
          REGISTRYRESOURCENAME: cve.REGISTRYRESOURCENAME,
          REPOSITORY: cve.REPOSITORY
        });
      });

      this.processReport(this.vulnerabilities);
    }
    reader.readAsBinaryString(file);
  }

  processReport(vulnerabilities: Vulnerability[]): void {
    this.vulnerabilityReport = {
      vulnerabilitiesBySeverity: this.organizeVulnerabilitiesBySeverity(vulnerabilities),
      vulnerabilitiesByCve: this.organizeVulnerabilitiesByCve(vulnerabilities),
      vulnerabilitiesByPackage: this.organizeVulnerabilitiesByPackage(vulnerabilities),
      vulnerabilitiesByRepo: this.organizeVulnerabilitiesByRepo(vulnerabilities),
      vulnerabilitiesByEnvironment: this.organizeVulnerabilitiesByEnvironment(vulnerabilities)
    };

    console.log(this.vulnerabilityReport);
  }

  organizeVulnerabilitiesBySeverity(vulnerabilities: Vulnerability[]) {
    const vulnerabilitySeverityMap = {
      criticals: {
        count: 0,
        vulnerabilities: {} as {
          [envName: string]: {
            vulnerabilities: Vulnerability[]
          }
        }
      },
      highs: {
        count: 0,
        vulnerabilities: {} as {
          [envName: string]: {
            vulnerabilities: Vulnerability[]
          }
        }
      },
      mediums: {
        count: 0,
        vulnerabilities: {} as {
          [envName: string]: {
            vulnerabilities: Vulnerability[]
          }
        }
      },
      lows: {
        count: 0,
        vulnerabilities: {} as {
          [envName: string]: {
            vulnerabilities: Vulnerability[]
          }
        }
      }
    }

    vulnerabilities.forEach(v => {
      const cveScore = v.CVSS3SCORE;

      if (cveScore >= 9) {
        vulnerabilitySeverityMap.criticals.count++;
        if (vulnerabilitySeverityMap.criticals.vulnerabilities[v.REGISTRYRESOURCENAME]) {
          vulnerabilitySeverityMap.criticals.vulnerabilities[v.REGISTRYRESOURCENAME].vulnerabilities.push(v);
        } else {
          vulnerabilitySeverityMap.criticals.vulnerabilities[v.REGISTRYRESOURCENAME] = {
            vulnerabilities: [v]
          };
        }
      } else if (cveScore >= 7 && cveScore < 9) {
        vulnerabilitySeverityMap.highs.count++;
        if (vulnerabilitySeverityMap.highs.vulnerabilities[v.REGISTRYRESOURCENAME]) {
          vulnerabilitySeverityMap.highs.vulnerabilities[v.REGISTRYRESOURCENAME].vulnerabilities.push(v);
        } else {
          vulnerabilitySeverityMap.highs.vulnerabilities[v.REGISTRYRESOURCENAME] = {
            vulnerabilities: [v]
          };
        }      } else if (cveScore >= 4 && cveScore < 7) {
        vulnerabilitySeverityMap.mediums.count++;
        if (vulnerabilitySeverityMap.mediums.vulnerabilities[v.REGISTRYRESOURCENAME]) {
          vulnerabilitySeverityMap.mediums.vulnerabilities[v.REGISTRYRESOURCENAME].vulnerabilities.push(v);
        } else {
          vulnerabilitySeverityMap.mediums.vulnerabilities[v.REGISTRYRESOURCENAME] = {
            vulnerabilities: [v]
          };
        }      } else {
        vulnerabilitySeverityMap.lows.count++;
        if (vulnerabilitySeverityMap.lows.vulnerabilities[v.REGISTRYRESOURCENAME]) {
          vulnerabilitySeverityMap.lows.vulnerabilities[v.REGISTRYRESOURCENAME].vulnerabilities.push(v);
        } else {
          vulnerabilitySeverityMap.lows.vulnerabilities[v.REGISTRYRESOURCENAME] = {
            vulnerabilities: [v]
          };
        }      }
    });

    return vulnerabilitySeverityMap;
  }

  organizeVulnerabilitiesByCve(vulnerabilities: Vulnerability[]) {
    const vulnerabilityCveMap: {
      [cveName: string]: {
        cveName: string;
        count: number;
        vulnerabilities: {
          [envName: string]: {
            vulnerabilities: Vulnerability[]
          }
        };
      }
    } = {};
    vulnerabilities.forEach(v => {
      const cveTitle: string = v.CVES.cves?.[0]?.title;
      if (!vulnerabilityCveMap[cveTitle]) {
        vulnerabilityCveMap[cveTitle] = {
          cveName: cveTitle,
          count: 1,
          vulnerabilities: {
            [v.REGISTRYRESOURCENAME]: {
              vulnerabilities: [v]
            }
          }
        };
      } else {
        const entry = vulnerabilityCveMap[cveTitle];
        if (entry) {
          entry.count++;
          if (entry.vulnerabilities[v.REGISTRYRESOURCENAME]) {
            entry.vulnerabilities[v.REGISTRYRESOURCENAME].vulnerabilities.push(v);
          } else {
            entry.vulnerabilities[v.REGISTRYRESOURCENAME] = {
              vulnerabilities: [v]
            };
          }
        }
      }
    });
    return vulnerabilityCveMap;
  }

  organizeVulnerabilitiesByPackage(vulnerabilities: Vulnerability[]) {
    const vulnerabilityPackageMap: {
      [packageName: string]: {
        packageName: string;
        count: number;
        vulnerabilities: {
          [envName: string]: {
            vulnerabilities: Vulnerability[]
          }
        };
      }
    } = {};
    vulnerabilities.forEach(v => {
      v.PACKAGES.packages.forEach(p => {
        const packageName: string = p?.name;
        if (!vulnerabilityPackageMap[packageName]) {
          vulnerabilityPackageMap[packageName] = {
            packageName,
            count: 1,
            vulnerabilities: {
              [v.REGISTRYRESOURCENAME]: {
                vulnerabilities: [v]
              }
            }
          };
        } else {
          const entry = vulnerabilityPackageMap[packageName];
          if (entry) {
            entry.count++;
            if (entry.vulnerabilities[v.REGISTRYRESOURCENAME]) {
              entry.vulnerabilities[v.REGISTRYRESOURCENAME].vulnerabilities.push(v);
            } else {
              entry.vulnerabilities[v.REGISTRYRESOURCENAME] = {
                vulnerabilities: [v]
              };
            }
          }
        }
      });
    });
    return vulnerabilityPackageMap;
  }

  organizeVulnerabilitiesByRepo(vulnerabilities: Vulnerability[]) {
    const vulnerabilityRepoMap: {
      [repository: string]: {
        repository: string;
        count: number;
        vulnerabilities: {
          [envName: string]: {
            vulnerabilities: Vulnerability[]
          }
        };
      }
    } = {};
    vulnerabilities.forEach(v => {
      const repoName: string = v.REPOSITORY;
      if (!vulnerabilityRepoMap[repoName]) {
        vulnerabilityRepoMap[repoName] = {
          repository: repoName,
          count: 1,
          vulnerabilities: {
            [v.REGISTRYRESOURCENAME]: {
              vulnerabilities: [v]
            }
          }
        };
      } else {
        const entry = vulnerabilityRepoMap[repoName];
        if (entry) {
          entry.count++;
          if (entry.vulnerabilities[v.REGISTRYRESOURCENAME]) {
            entry.vulnerabilities[v.REGISTRYRESOURCENAME].vulnerabilities.push(v);
          } else {
            entry.vulnerabilities[v.REGISTRYRESOURCENAME] = {
              vulnerabilities: [v]
            };
          }
        }
      }
    });
    return vulnerabilityRepoMap;
  }

  organizeVulnerabilitiesByEnvironment(vulnerabilities: Vulnerability[]) {
    const vulnerabilityEnvMap: {
      [envName: string]: {
        environment: string;
        count: number;
        vulnerabilities: {
          [repoName: string]: {
            vulnerabilities: Vulnerability[]
          }
        };
      }
    } = {};

    vulnerabilityEnvMap['ecpacrcommon'] = {environment: 'ecpacrcommon', count: 0, vulnerabilities: {}};
    vulnerabilityEnvMap['ecpstgacrcommon'] = {environment: 'ecpstgacrcommon', count: 0, vulnerabilities: {}};
    vulnerabilityEnvMap['ecpprdacrcommon'] = {environment: 'ecpprdacrcommon', count: 0, vulnerabilities: {}};

    vulnerabilities.forEach(v => {
      const environment: string = v.REGISTRYRESOURCENAME;
      const entry = vulnerabilityEnvMap[environment];
      if (entry) {
        entry.count++;
        if (entry.vulnerabilities[v.REPOSITORY]) {
          entry.vulnerabilities[v.REPOSITORY].vulnerabilities.push(v);
        } else {
          entry.vulnerabilities[v.REPOSITORY] = {
            vulnerabilities: [v]
          };
        }
      }
    });
    return vulnerabilityEnvMap;
  }
}
